{
  "deckName": "Java Inheritance",
  "flashcards": [
    {
      "id": 1,
      "question": "What is Inheritance in Java?",
      "answer": "A mechanism where a new class (subclass) derives properties and behaviors from an existing class (superclass).",
      "category": "Inheritance Fundamentals",
      "detailedExplanation": "Inheritance is one of the four fundamental OOP concepts in Java. It allows a new class (called subclass, child class, or derived class) to inherit the fields and methods of an existing class (called superclass, parent class, or base class). This promotes code reusability and establishes a natural hierarchy between classes.\n\nThe subclass can add its own fields and methods, and can also override inherited methods to provide specific implementations. Inheritance represents an 'is-a' relationship between classes.",
      "keyPoints": [
        "Promotes code reusability",
        "Establishes 'is-a' relationship",
        "Subclass inherits from superclass",
        "Supports method overriding"
      ],
      "examples": [
        "class Car extends Vehicle { }",
        "class Student extends Person { }"
      ]
    },
    {
      "id": 2,
      "question": "What are the main types of inheritance in Java?",
      "answer": "Single, Multilevel, Hierarchical, Multiple (through interfaces), and Hybrid inheritance.",
      "category": "Inheritance Types",
      "detailedExplanation": "Java supports several types of inheritance to model different relationship patterns:\n\n**Single Inheritance**: A class inherits from only one superclass.\n**Multilevel Inheritance**: A class inherits from a subclass, creating a chain (A→B→C).\n**Hierarchical Inheritance**: Multiple classes inherit from a single superclass.\n**Multiple Inheritance**: A class inherits from multiple classes (achieved through interfaces in Java).\n**Hybrid Inheritance**: A combination of two or more inheritance types.\n\nJava doesn't support multiple inheritance with classes to avoid complexity and the 'diamond problem', but it's achieved through interfaces.",
      "keyPoints": [
        "Single: One superclass per subclass",
        "Multilevel: Inheritance chain",
        "Hierarchical: Multiple subclasses from one superclass",
        "Multiple: Through interfaces only"
      ],
      "examples": [
        "Single: class B extends A",
        "Multilevel: class C extends B, class B extends A",
        "Hierarchical: class B extends A, class C extends A"
      ]
    },
    {
      "id": 3,
      "question": "What is the 'super' keyword and how is it used?",
      "answer": "A reference variable used to refer to immediate parent class object, methods, and constructors.",
      "category": "Inheritance Keywords",
      "detailedExplanation": "The 'super' keyword in Java has three main uses:\n\n1. **Referring to Parent Class Instance Variable**: Used when child and parent class have same-named variables.\n2. **Invoking Parent Class Method**: Used to call overridden methods of the parent class.\n3. **Invoking Parent Class Constructor**: Used to call parent class constructor from child class constructor.\n\nThe 'super' keyword helps eliminate naming conflicts and ensures proper initialization of parent class members before child class members.",
      "keyPoints": [
        "Refers to immediate parent class",
        "Access parent class variables and methods",
        "Call parent class constructors",
        "Must be first statement in constructor"
      ],
      "examples": [
        "super.variableName - access parent variable",
        "super.methodName() - call parent method",
        "super() - call parent constructor"
      ]
    },
    {
      "id": 4,
      "question": "What are the different access modifiers and their visibility in inheritance?",
      "answer": "public, protected, default (package-private), and private - with varying inheritance visibility.",
      "category": "Access Control",
      "detailedExplanation": "Access modifiers control the visibility of class members in inheritance:\n\n**public**: Accessible everywhere, including subclasses in any package.\n**protected**: Accessible within same package and to subclasses (even in different packages).\n**default (no modifier)**: Accessible only within the same package.\n**private**: Not accessible to subclasses, only within the same class.\n\nIn inheritance, subclasses can access public and protected members of the parent class, but cannot access private members directly.",
      "keyPoints": [
        "public: Global access",
        "protected: Package + subclasses access",
        "default: Package access only",
        "private: Class access only"
      ],
      "examples": [
        "public methods - inherited by all subclasses",
        "protected variables - accessible to subclasses",
        "private members - not accessible to subclasses"
      ]
    },
    {
      "id": 5,
      "question": "What is Method Overriding in inheritance?",
      "answer": "When a subclass provides a specific implementation of a method already defined in its superclass.",
      "category": "Polymorphism",
      "detailedExplanation": "Method overriding occurs when a subclass has a method with the same name, return type, and parameters as a method in its superclass. The subclass method 'overrides' the parent class method to provide its own specific implementation.\n\n**Rules for Method Overriding:**\n- Method name and parameters must be exactly the same\n- Return type should be the same or covariant (subtype)\n- Access modifier cannot be more restrictive\n- Cannot override static, final, or private methods\n- Use @Override annotation for better code clarity",
      "keyPoints": [
        "Same method signature as parent",
        "Provides specific implementation",
        "Runtime polymorphism",
        "Cannot override static/final methods"
      ],
      "examples": [
        "Parent: void display() { ... }",
        "Child: @Override void display() { ... }"
      ]
    },
    {
      "id": 6,
      "question": "What is the difference between method overloading and method overriding?",
      "answer": "Overloading: Same method name, different parameters. Overriding: Same method signature in subclass.",
      "category": "Polymorphism Comparison",
      "detailedExplanation": "**Method Overloading (Compile-time Polymorphism):**\n- Same method name, different parameters\n- Can have different return types\n- Within same class\n- Compile-time decision\n\n**Method Overriding (Runtime Polymorphism):**\n- Same method name and parameters\n- Same or covariant return type\n- Between superclass and subclass\n- Runtime decision\n- Cannot override static/final/private methods\n\nOverloading increases readability, while overriding enables polymorphism.",
      "keyPoints": [
        "Overloading: Same class, different parameters",
        "Overriding: Different classes, same signature",
        "Overloading: Compile-time decision",
        "Overriding: Runtime decision"
      ],
      "examples": [
        "Overloading: void show(int a) and void show(String s)",
        "Overriding: Parent: show(), Child: show()"
      ]
    },
    {
      "id": 7,
      "question": "What are abstract classes and methods in inheritance?",
      "answer": "Abstract classes cannot be instantiated and may contain abstract methods without implementation.",
      "category": "Abstraction",
      "detailedExplanation": "**Abstract Class:**\n- Declared with 'abstract' keyword\n- Cannot be instantiated\n- May contain abstract and concrete methods\n- Used as base classes for inheritance\n\n**Abstract Method:**\n- Declared without implementation (no body)\n- Must be overridden by concrete subclasses\n- Forces subclasses to provide specific implementations\n\nAbstract classes are used when you want to define a common interface for subclasses while providing some common functionality.",
      "keyPoints": [
        "Abstract classes cannot be instantiated",
        "May contain abstract and concrete methods",
        "Abstract methods have no implementation",
        "Subclasses must implement abstract methods"
      ],
      "examples": [
        "abstract class Shape { abstract void draw(); }",
        "class Circle extends Shape { void draw() { ... } }"
      ]
    },
    {
      "id": 8,
      "question": "What are final classes and methods in inheritance?",
      "answer": "Final classes cannot be extended, final methods cannot be overridden.",
      "category": "Inheritance Restrictions",
      "detailedExplanation": "The 'final' keyword imposes restrictions on inheritance:\n\n**Final Class:**\n- Cannot be extended (no subclasses)\n- Used for security or design reasons\n- All methods in final class are implicitly final\n\n**Final Method:**\n- Cannot be overridden by subclasses\n- Used when method implementation should not change\n- Improves performance (static binding)\n\n**Final Variable:**\n- Constant value that cannot be changed\n- Must be initialized when declared or in constructor",
      "keyPoints": [
        "Final class: Cannot be subclassed",
        "Final method: Cannot be overridden",
        "Final variable: Constant value",
        "Improves security and performance"
      ],
      "examples": [
        "final class Math { ... } - cannot be extended",
        "final void display() { ... } - cannot be overridden"
      ]
    },
    {
      "id": 9,
      "question": "What is constructor chaining in inheritance?",
      "answer": "The process of calling constructors sequentially from child to parent classes during object creation.",
      "category": "Constructors in Inheritance",
      "detailedExplanation": "When an object of a subclass is created, constructors are called in a specific sequence:\n\n1. **Implicit super() call**: If no explicit super() call, Java automatically calls parent's default constructor\n2. **Parent class constructor** executes first\n3. **Child class constructor** executes after parent constructor completes\n\n**Key Points:**\n- super() must be first statement in constructor\n- If parent doesn't have default constructor, child must explicitly call super(parameters)\n- Constructor chaining ensures proper initialization hierarchy",
      "keyPoints": [
        "Parent constructor called first",
        "super() must be first statement",
        "Automatic call to parent default constructor",
        "Ensures proper initialization order"
      ],
      "examples": [
        "Child() { super(); ... } - explicit parent call",
        "Child(int x) { super(x); ... } - parameterized parent call"
      ]
    },
    {
      "id": 10,
      "question": "What is the 'instanceof' operator in inheritance?",
      "answer": "A boolean operator that tests if an object is an instance of a specific class or interface.",
      "category": "Type Checking",
      "detailedExplanation": "The instanceof operator checks whether an object is an instance of a particular class, subclass, or interface. It returns true if the object is an instance of the specified type, false otherwise.\n\n**Usage:**\n- Check object type before casting\n- Avoid ClassCastException\n- Useful in polymorphic scenarios\n- Works with class hierarchy and interfaces\n\nThe operator follows inheritance hierarchy - if object is instance of subclass, it's also instance of superclass.",
      "keyPoints": [
        "Checks object type",
        "Returns boolean result",
        "Works with classes and interfaces",
        "Prevents ClassCastException"
      ],
      "examples": [
        "if (obj instanceof Car) { Car c = (Car)obj; }",
        "obj instanceof Vehicle - true for Car objects"
      ]
    },
    {
      "id": 11,
      "question": "What is the Object class in Java inheritance?",
      "answer": "The root class of all Java classes - every class implicitly extends Object class.",
      "category": "Java Foundation",
      "detailedExplanation": "The Object class is the superclass of all classes in Java. If a class doesn't explicitly extend another class, it implicitly extends the Object class.\n\n**Important Methods in Object Class:**\n- toString(): Returns string representation of object\n- equals(): Compares objects for equality\n- hashCode(): Returns hash code value\n- getClass(): Returns runtime class of object\n- clone(): Creates and returns copy of object\n- finalize(): Called by garbage collector before destruction\n\nUnderstanding these methods is crucial as they're commonly overridden in custom classes.",
      "keyPoints": [
        "Root class of all Java classes",
        "Implicitly extended by all classes",
        "Contains fundamental methods",
        "Commonly overridden methods"
      ],
      "examples": [
        "class Car { } // implicitly extends Object",
        "@Override public String toString() { ... }"
      ]
    },
    {
      "id": 12,
      "question": "What are the advantages and disadvantages of inheritance?",
      "answer": "Advantages: Code reuse, extensibility. Disadvantages: Tight coupling, complex hierarchy.",
      "category": "Inheritance Analysis",
      "detailedExplanation": "**Advantages:**\n- **Code Reusability**: Inherit existing functionality\n- **Extensibility**: Easily add new features\n- **Polymorphism**: Runtime method binding\n- **Organization**: Natural class hierarchy\n\n**Disadvantages:**\n- **Tight Coupling**: Changes in parent affect children\n- **Complex Hierarchy**: Deep inheritance hard to maintain\n- **Fragile Base Class**: Parent changes break children\n- **Overuse**: 'Is-a' relationship misused\n\n**Best Practices:**\n- Use inheritance only for true 'is-a' relationships\n- Prefer composition over inheritance when possible\n- Keep inheritance hierarchy shallow",
      "keyPoints": [
        "Advantages: Reusability, extensibility, polymorphism",
        "Disadvantages: Coupling, complexity, fragility",
        "Use for true 'is-a' relationships",
        "Prefer composition when appropriate"
      ],
      "examples": [
        "Good: Car extends Vehicle (true is-a)",
        "Bad: DatabaseManager extends StringUtils (not is-a)"
      ]
    }
  ],
  "mcqs": [
    {
      "id": 1,
      "question": "Which keyword is used to inherit a class in Java?",
      "options": [
        "implements",
        "inherits",
        "extends",
        "super"
      ],
      "correctAnswer": "extends",
      "category": "Inheritance Fundamentals"
    },
    {
      "id": 2,
      "question": "Which type of inheritance is NOT supported by Java through classes?",
      "options": [
        "Single inheritance",
        "Multiple inheritance",
        "Multilevel inheritance",
        "Hierarchical inheritance"
      ],
      "correctAnswer": "Multiple inheritance",
      "category": "Inheritance Types"
    },
    {
      "id": 3,
      "question": "What is the output of: class A { } class B extends A { } System.out.println(B instanceof A);",
      "options": [
        "true",
        "false",
        "Compilation error",
        "Runtime error"
      ],
      "correctAnswer": "Compilation error",
      "category": "Type Checking"
    },
    {
      "id": 4,
      "question": "Which access modifier allows visibility to subclasses in different packages?",
      "options": [
        "private",
        "default",
        "protected",
        "public"
      ],
      "correctAnswer": "protected",
      "category": "Access Control"
    },
    {
      "id": 5,
      "question": "What happens if a subclass doesn't call super() explicitly in its constructor?",
      "options": [
        "Compilation error",
        "Runtime error",
        "Java automatically calls super()",
        "Parent constructor is not called"
      ],
      "correctAnswer": "Java automatically calls super()",
      "category": "Constructors in Inheritance"
    },
    {
      "id": 6,
      "question": "Which method in Object class is used to get string representation of an object?",
      "options": [
        "toString()",
        "getString()",
        "stringValue()",
        "convertString()"
      ],
      "correctAnswer": "toString()",
      "category": "Java Foundation"
    },
    {
      "id": 7,
      "question": "What is the main purpose of method overriding?",
      "options": [
        "To improve performance",
        "To provide specific implementation in subclass",
        "To hide parent class methods",
        "To create multiple methods with same name"
      ],
      "correctAnswer": "To provide specific implementation in subclass",
      "category": "Polymorphism"
    },
    {
      "id": 8,
      "question": "Which keyword prevents a class from being inherited?",
      "options": [
        "static",
        "final",
        "private",
        "abstract"
      ],
      "correctAnswer": "final",
      "category": "Inheritance Restrictions"
    },
    {
      "id": 9,
      "question": "In multilevel inheritance A→B→C, which constructor is called first when creating C object?",
      "options": [
        "C constructor",
        "B constructor",
        "A constructor",
        "All simultaneously"
      ],
      "correctAnswer": "A constructor",
      "category": "Constructors in Inheritance"
    },
    {
      "id": 10,
      "question": "What is the relationship between composition and inheritance?",
      "options": [
        "They are the same concept",
        "Composition is 'has-a', inheritance is 'is-a'",
        "Inheritance is 'has-a', composition is 'is-a'",
        "They are mutually exclusive"
      ],
      "correctAnswer": "Composition is 'has-a', inheritance is 'is-a'",
      "category": "Inheritance Analysis"
    }
  ]
}
