{
  "deckName": "ISC Class 12 Computer Science - Inheritance",
  "flashcards": [
    {
      "id": 1,
      "question": "What is inheritance in object-oriented programming?",
      "answer": "Inheritance is a mechanism where a new class (derived class) acquires properties and methods from an existing class (base class).",
      "category": "Introduction to Inheritance",
      "detailedExplanation": "Inheritance is a fundamental concept in object-oriented programming that allows creating new classes based on existing classes. The derived class (subclass) inherits attributes and methods from the base class (superclass), promoting code reusability. This establishes an 'is-a' relationship between classes, where the derived class is a specialized version of the base class. For example, if we have a base class 'Vehicle', we can create derived classes like 'Car', 'Bike', and 'Truck' that inherit common properties from Vehicle while adding their own specific features.",
      "keyPoints": [
        "Allows code reusability",
        "Creates 'is-a' relationship between classes",
        "Derived class inherits from base class",
        "Promotes hierarchical classification"
      ],
      "examples": [
        "Vehicle → Car, Bike, Truck",
        "Shape → Circle, Rectangle, Triangle",
        "Person → Student, Teacher, Employee"
      ]
    },
    {
      "id": 2,
      "question": "What are the main advantages of using inheritance?",
      "answer": "Code reusability, method overriding, and creating class hierarchies.",
      "category": "Need of Inheritance",
      "detailedExplanation": "Inheritance provides several important benefits in programming. The primary advantage is code reusability - we can write common functionality in a base class and reuse it in multiple derived classes without rewriting the same code. This reduces code duplication and makes maintenance easier. Inheritance also enables method overriding, where derived classes can provide their own implementation of inherited methods. Additionally, it helps in creating natural class hierarchies that model real-world relationships. For ISC syllabus, understanding these advantages is crucial for designing efficient object-oriented programs.",
      "keyPoints": [
        "Eliminates code duplication",
        "Easy maintenance and updates",
        "Supports method overriding",
        "Creates logical class relationships"
      ],
      "examples": [
        "Common attributes in base class Person reused in Student and Teacher",
        "calculateArea() method overridden in Circle and Rectangle",
        "Vehicle hierarchy with common fuel-related methods"
      ]
    },
    {
      "id": 3,
      "question": "What are the different types of inheritance?",
      "answer": "Single, multilevel, hierarchical, and multiple inheritance.",
      "category": "Types of Inheritance",
      "detailedExplanation": "Inheritance can be implemented in different ways depending on the relationship between classes. Single inheritance is when a class inherits from only one base class. Multilevel inheritance involves a chain of inheritance where class A is base for B, and B is base for C. Hierarchical inheritance occurs when multiple classes inherit from a single base class. Multiple inheritance, where a class inherits from more than one base class, is not supported in Java through classes but can be achieved using interfaces. For ISC Class 12, focus on understanding single and multilevel inheritance as they are most commonly used.",
      "keyPoints": [
        "Single: One base, one derived class",
        "Multilevel: Chain of inheritance (A→B→C)",
        "Hierarchical: One base, multiple derived classes",
        "Multiple: Not supported in Java with classes"
      ],
      "examples": [
        "Single: Car inherits from Vehicle",
        "Multilevel: Animal → Mammal → Human",
        "Hierarchical: Shape → Circle, Rectangle, Triangle"
      ]
    },
    {
      "id": 4,
      "question": "What are visibility modes in inheritance?",
      "answer": "Public, protected, and private inheritance modes that control member accessibility.",
      "category": "Visibility Modes",
      "detailedExplanation": "Visibility modes determine how base class members are inherited in the derived class. In public inheritance, public members remain public, protected remain protected. In protected inheritance, both public and protected members become protected in derived class. In private inheritance, all inherited members become private. Private members of base class are never directly accessible in derived class regardless of visibility mode. In Java, we mainly use public inheritance, but understanding all modes is important for comprehensive knowledge.",
      "keyPoints": [
        "Public inheritance: Maintains original access levels",
        "Protected inheritance: Public becomes protected",
        "Private inheritance: All become private",
        "Private base members are never directly accessible"
      ],
      "examples": [
        "Public: Vehicle → Car (public methods remain public)",
        "Protected: Base → Middle class for further derivation",
        "Private: Implementation hiding"
      ]
    },
    {
      "id": 5,
      "question": "How can we access base class members from derived class?",
      "answer": "Using super keyword in Java or scope resolution in C++.",
      "category": "Accessing Base Class Members",
      "detailedExplanation": "To access base class members from derived class, we use specific keywords. In Java, the 'super' keyword is used to refer to immediate parent class. We can use super to call parent class constructor (super()), access parent class methods (super.methodName()), or refer to parent class variables. This is particularly useful when we have method overriding and want to call the parent class version of the method. Understanding how to properly use super is essential for working with inheritance in Java programs.",
      "keyPoints": [
        "Use super() to call base class constructor",
        "Use super.method() to call overridden methods",
        "super must be first statement in constructor",
        "Used to resolve naming conflicts"
      ],
      "examples": [
        "super() in derived class constructor",
        "super.display() to call parent class method",
        "Using super in method overriding scenarios"
      ]
    },
    {
      "id": 6,
      "question": "What happens to private members of base class in inheritance?",
      "answer": "Private members are inherited but not directly accessible in derived class.",
      "category": "Private Members",
      "detailedExplanation": "Private members of the base class are inherited by the derived class in terms of memory allocation, but they cannot be accessed directly by the derived class. The derived class can only access these private members through public or protected methods provided by the base class. This maintains encapsulation and data hiding principles. For example, if a base class has private variables, the derived class must use public getter and setter methods to work with those variables. This is an important concept for ISC exams as it tests understanding of access control in inheritance.",
      "keyPoints": [
        "Private members are inherited",
        "Not directly accessible in derived class",
        "Accessible only through public/protected methods",
        "Maintains encapsulation principle"
      ],
      "examples": [
        "Using getName() method to access private name variable",
        "Setter methods to modify private data",
        "Private variables exist in derived class object"
      ]
    },
    {
      "id": 7,
      "question": "What is the purpose of protected access specifier?",
      "answer": "To allow access to derived classes while hiding from external code.",
      "category": "Protected Members",
      "detailedExplanation": "The protected access specifier provides a balance between public and private access. Protected members are accessible within the same class, by derived classes, and within the same package, but not by unrelated external classes. This is useful when we want to share implementation details with derived classes while keeping them hidden from the rest of the program. For ISC syllabus, understanding when to use protected instead of private or public is important for designing good class hierarchies that maintain proper encapsulation.",
      "keyPoints": [
        "Accessible by derived classes",
        "Not accessible by external classes",
        "Useful for inheritance hierarchies",
        "Balances accessibility and encapsulation"
      ],
      "examples": [
        "Protected variables for derived class access",
        "Protected methods for derived class overriding",
        "Helper methods shared in inheritance tree"
      ]
    },
    {
      "id": 8,
      "question": "What is polymorphism in Java?",
      "answer": "The ability of an object to take many forms, achieved through method overloading and overriding.",
      "category": "Polymorphism",
      "detailedExplanation": "Polymorphism means 'many forms' and is a core concept in object-oriented programming. In Java, polymorphism allows us to perform a single action in different ways. There are two types: compile-time polymorphism (method overloading) and runtime polymorphism (method overriding). Method overloading occurs when multiple methods have same name but different parameters. Method overriding occurs when a derived class provides a specific implementation of a method already defined in its base class. For ISC Class 12, focus on method overriding as it's closely related to inheritance.",
      "keyPoints": [
        "Compile-time: Method overloading",
        "Runtime: Method overriding",
        "Same method name, different behaviors",
        "Essential for flexible code design"
      ],
      "examples": [
        "Shape class with calculateArea() overridden in Circle, Rectangle",
        "Animal class with makeSound() giving different sounds",
        "BankAccount with different calculateInterest() implementations"
      ]
    },
    {
      "id": 9,
      "question": "What is method overriding and how is it done?",
      "answer": "Redefining a base class method in derived class with same signature.",
      "category": "Method Overriding",
      "detailedExplanation": "Method overriding occurs when a derived class provides a specific implementation for a method that is already defined in its base class. For successful overriding, the method must have the same name, same return type, and same parameters as the method in the parent class. The access level cannot be more restrictive than the parent method. In Java, we use the @Override annotation to indicate we are overriding a method, which helps in catching errors at compile time. Overriding is fundamental for achieving runtime polymorphism in inheritance hierarchies.",
      "keyPoints": [
        "Same method signature required",
        "Cannot reduce accessibility",
        "Use @Override annotation",
        "Enables runtime polymorphism"
      ],
      "examples": [
        "Vehicle → Car (both have start() method)",
        "BankAccount → SavingsAccount (both have calculateInterest())",
        "Shape → Circle (both have calculateArea())"
      ]
    },
    {
      "id": 10,
      "question": "How do we call superclass constructor from derived class?",
      "answer": "Using super() as the first statement in derived class constructor.",
      "category": "Superclass Constructor",
      "detailedExplanation": "When creating an object of a derived class, the constructor of the base class must be called first to ensure proper initialization. In Java, this is done using the super() keyword in the derived class constructor. The super() call must be the first statement in the constructor. If we don't explicitly call super(), the compiler automatically inserts a call to the no-argument constructor of the base class. If the base class doesn't have a no-argument constructor, we must explicitly call the appropriate constructor using super with parameters.",
      "keyPoints": [
        "super() must be first statement",
        "Automatic call to no-arg constructor if not specified",
        "Used to initialize base class part of object",
        "Parameters can be passed to base constructor"
      ],
      "examples": [
        "super() calls no-argument base constructor",
        "super(name, age) calls parameterized constructor",
        "Implicit super() when not specified"
      ]
    }
  ],
  "mcqs": [
    {
      "id": 1,
      "question": "Which type of inheritance is not supported in Java through classes?",
      "options": ["Single inheritance", "Multilevel inheritance", "Hierarchical inheritance", "Multiple inheritance"],
      "correctAnswer": "Multiple inheritance",
      "category": "Types of Inheritance",
      "explanation": "Java does not support multiple inheritance with classes to avoid complexity and ambiguity. However, it can be achieved using interfaces."
    },
    {
      "id": 2,
      "question": "What is the output of: class A { int x=10; } class B extends A { int x=20; void show() { System.out.println(super.x); }}",
      "options": ["10", "20", "Compilation error", "Runtime error"],
      "correctAnswer": "10",
      "category": "Accessing Base Class Members",
      "explanation": "super.x refers to the x variable of the parent class A, which has value 10."
    },
    {
      "id": 3,
      "question": "Which keyword is used to call base class constructor from derived class?",
      "options": ["this", "super", "base", "parent"],
      "correctAnswer": "super",
      "category": "Superclass Constructor",
      "explanation": "The super keyword is used to call base class constructor from derived class constructor."
    },
    {
      "id": 4,
      "question": "What happens to private members of base class in derived class?",
      "options": ["Not inherited", "Become public", "Become protected", "Inherited but not accessible"],
      "correctAnswer": "Inherited but not accessible",
      "category": "Private Members",
      "explanation": "Private members are inherited in terms of memory allocation but cannot be accessed directly in derived class."
    },
    {
      "id": 5,
      "question": "Which access specifier allows access to derived classes but not to external classes?",
      "options": ["public", "private", "protected", "default"],
      "correctAnswer": "protected",
      "category": "Protected Members",
      "explanation": "Protected members are accessible within the same class, derived classes, and same package, but not by external classes."
    },
    {
      "id": 6,
      "question": "What is the main advantage of inheritance?",
      "options": ["Faster execution", "Code reusability", "Smaller file size", "Better memory management"],
      "correctAnswer": "Code reusability",
      "category": "Need of Inheritance",
      "explanation": "The primary advantage of inheritance is code reusability - we can reuse existing code from base classes."
    },
    {
      "id": 7,
      "question": "In method overriding, the method in derived class must have:",
      "options": ["Same name only", "Same name and return type", "Same name and parameters", "Same name, return type and parameters"],
      "correctAnswer": "Same name, return type and parameters",
      "category": "Method Overriding",
      "explanation": "For method overriding, the method signature (name, return type, and parameters) must be exactly the same."
    },
    {
      "id": 8,
      "question": "Which concept allows an object to take many forms?",
      "options": ["Inheritance", "Encapsulation", "Polymorphism", "Abstraction"],
      "correctAnswer": "Polymorphism",
      "category": "Polymorphism",
      "explanation": "Polymorphism allows objects of different classes to be treated as objects of a common super class."
    },
    {
      "id": 9,
      "question": "Where must super() call be placed in derived class constructor?",
      "options": ["Anywhere", "Last statement", "First statement", "Not required"],
      "correctAnswer": "First statement",
      "category": "Superclass Constructor",
      "explanation": "The super() call must be the first statement in the derived class constructor."
    },
    {
      "id": 10,
      "question": "What is the relationship between base and derived class called?",
      "options": ["Has-a", "Is-a", "Uses-a", "Contains-a"],
      "correctAnswer": "Is-a",
      "category": "Introduction to Inheritance",
      "explanation": "Inheritance creates an 'is-a' relationship where derived class is a specialized version of base class."
    }
  ]
}
