{
  "deckName": "Java Recursion",
  "flashcards": [
    {
      "id": 1,
      "question": "What is Recursion in programming?",
      "answer": "A programming technique where a function calls itself from within its own block.",
      "category": "Recursion Fundamentals",
      "detailedExplanation": "Recursion is a powerful programming technique where a function solves a problem by calling itself on a smaller or simpler version of the same problem. It's an alternative to iterative approaches (like loops) and is especially useful for problems that can be broken down into similar sub-problems.\n\nThe key to recursion is that each recursive call should work on a smaller input, progressing towards a base case that stops the recursion. Without a proper base case, recursion would continue infinitely, leading to a stack overflow error.",
      "keyPoints": [
        "Function calls itself",
        "Solves problems by breaking them into smaller sub-problems",
        "Requires a base case to terminate",
        "Alternative to iterative loops"
      ],
      "examples": [
        "Calculating factorial: n! = n × (n-1)!",
        "Fibonacci sequence: fib(n) = fib(n-1) + fib(n-2)"
      ]
    },
    {
      "id": 2,
      "question": "What are the two essential components of a recursive function?",
      "answer": "Base Case and Recursive Case",
      "category": "Recursion Structure",
      "detailedExplanation": "Every recursive function must have two critical components that work together:\n\n**Base Case**: The condition that stops the recursion. It provides the simplest, smallest instance of the problem that can be solved directly without further recursion. Without a base case, the function would call itself indefinitely.\n\n**Recursive Case**: The part where the function calls itself with a modified (usually smaller) version of the original problem. This moves the computation toward the base case.\n\nThe recursive process continues until the base case is reached, then 'unwinds' back through all the recursive calls to produce the final result.",
      "keyPoints": [
        "Base Case - stops recursion, provides direct solution",
        "Recursive Case - calls function with smaller input",
        "Base case must be reachable",
        "Each call should progress toward base case"
      ],
      "examples": [
        "Factorial: if(n==0) return 1; (base) else return n*fact(n-1); (recursive)",
        "Fibonacci: if(n<=1) return n; (base) else return fib(n-1)+fib(n-2); (recursive)"
      ]
    },
    {
      "id": 3,
      "question": "What is the role of the Stack in recursion?",
      "answer": "The stack stores function call references and local variables for each recursive call until the base case is reached.",
      "category": "Recursion Mechanics",
      "detailedExplanation": "When a recursive function executes, the system uses a Stack data structure (call stack) to manage the multiple function calls. Each time a function calls itself:\n\n1. **PUSH Operation**: The current function state (parameters, local variables, return address) is pushed onto the stack\n2. **Recursive Call**: The function executes with new parameters\n3. **Base Case Reached**: The recursion stops and values start returning\n4. **POP Operation**: As each function call completes, its frame is popped from the stack and the return value is passed back\n\nThis LIFO (Last-In-First-Out) behavior of the stack enables the 'backtracking' that makes recursion work. If recursion goes too deep, it can cause Stack Overflow.",
      "keyPoints": [
        "Uses LIFO (Last-In-First-Out) stack",
        "Each call creates a stack frame",
        "Stack stores parameters, variables, return addresses",
        "Stack overflow occurs if recursion too deep"
      ],
      "examples": [
        "fact(3) creates: fact(3) → fact(2) → fact(1) → fact(0) on stack",
        "When fact(0) returns 1, stack unwinds: fact(1) → fact(2) → fact(3)"
      ]
    },
    {
      "id": 4,
      "question": "What are the advantages and limitations of recursion?",
      "answer": "Advantages: Code simplicity, readability. Limitations: Higher memory usage, slower execution for some cases.",
      "category": "Recursion Analysis",
      "detailedExplanation": "**Advantages:**\n- **Code Simplicity**: Often leads to cleaner, more readable code\n- **Natural Fit**: Some problems are naturally recursive (tree traversal, Tower of Hanoi)\n- **Minimal Variables**: Fewer loop variables needed\n- **Easier Debugging**: Clear logical flow for certain algorithms\n\n**Limitations:**\n- **Memory Usage**: Each call consumes stack space\n- **Performance Overhead**: Function call overhead can make it slower than iteration\n- **Stack Overflow**: Deep recursion can exhaust stack memory\n- **Complexity**: Can be harder to understand for beginners\n\nRecursion is best suited for problems with recursive mathematical definitions or hierarchical data structures.",
      "keyPoints": [
        "Advantages: Simple, readable, natural for some problems",
        "Limitations: More memory, slower, stack overflow risk",
        "Good for: Tree traversal, divide-and-conquer algorithms",
        "Bad for: Simple iterations, performance-critical code"
      ],
      "examples": [
        "Good use: Directory tree traversal, mathematical sequences",
        "Poor use: Simple counting, large input sizes"
      ]
    },
    {
      "id": 5,
      "question": "What is Tail Recursion?",
      "answer": "A recursive function where the recursive call is the very last operation in the function.",
      "category": "Recursion Types",
      "detailedExplanation": "Tail recursion is a specific form of recursion where the recursive call is the final operation performed in the function before returning. This means there's no pending operation waiting after the recursive call returns.\n\n**Characteristics:**\n- Recursive call is the last statement\n- No operations performed after recursive call\n- Can be optimized by compilers (tail call optimization)\n- Results in more efficient stack usage\n\nIn tail recursion, since there's nothing to do after the recursive call returns, the current stack frame can be reused rather than creating a new one. However, not all Java implementations perform this optimization.",
      "keyPoints": [
        "Recursive call is last operation",
        "No pending operations after call",
        "Potentially optimizable",
        "Factorial calculation is classic example"
      ],
      "examples": [
        "Tail recursive: return fact(n-1, n*accumulator);",
        "Not tail recursive: return n * fact(n-1); (multiplication happens after call)"
      ]
    },
    {
      "id": 6,
      "question": "What is Binary Recursion?",
      "answer": "Recursion where a function makes two recursive calls from within its body.",
      "category": "Recursion Types",
      "detailedExplanation": "Binary recursion occurs when a recursive function makes two distinct recursive calls within its execution. This often happens in algorithms that need to explore two different paths or divide a problem into two subproblems.\n\n**Common Use Cases:**\n- Binary tree traversals\n- Fibonacci sequence calculation\n- Divide-and-conquer algorithms\n- Combinatorial problems\n\nBinary recursion can lead to exponential time complexity if not carefully designed, as each call generates two more calls. Techniques like memoization are often used to optimize binary recursive functions.",
      "keyPoints": [
        "Two recursive calls in function",
        "Common in tree structures",
        "Can cause exponential growth",
        "Often needs optimization"
      ],
      "examples": [
        "Fibonacci: return fib(n-1) + fib(n-2);",
        "Binary tree: process(left); process(right);"
      ]
    },
    {
      "id": 7,
      "question": "What is Indirect (Mutual) Recursion?",
      "answer": "When two or more functions call each other in a circular manner.",
      "category": "Recursion Types",
      "detailedExplanation": "Indirect recursion, also called mutual recursion, occurs when multiple functions call each other in a cycle, rather than a function calling itself directly.\n\n**How it works:**\n- Function A calls Function B\n- Function B calls Function A\n- This creates a recursive cycle\n- Both functions need base cases to terminate\n\nThis pattern is useful when a problem naturally divides into two interrelated subproblems. Both functions work together to solve the overall problem, with each handling a different aspect of the computation.",
      "keyPoints": [
        "Multiple functions call each other",
        "Circular calling pattern",
        "All functions need base cases",
        "Useful for interrelated subproblems"
      ],
      "examples": [
        "isEven(n) calls isOdd(n-1), isOdd(n) calls isEven(n-1)",
        "Parser functions that handle different syntax elements"
      ]
    },
    {
      "id": 8,
      "question": "How does recursion work for factorial calculation?",
      "answer": "n! = n × (n-1)! with base case 0! = 1",
      "category": "Recursion Examples",
      "detailedExplanation": "The factorial function is a classic example of recursion. The mathematical definition is naturally recursive:\n\n**Mathematical Definition:**\n- 0! = 1 (base case)\n- n! = n × (n-1)! for n > 0 (recursive case)\n\n**Execution for fact(3):**\n1. fact(3) = 3 × fact(2)\n2. fact(2) = 2 × fact(1)\n3. fact(1) = 1 × fact(0)\n4. fact(0) = 1 (base case reached)\n5. Backtrack: fact(1) = 1 × 1 = 1\n6. Backtrack: fact(2) = 2 × 1 = 2\n7. Backtrack: fact(3) = 3 × 2 = 6\n\nThis demonstrates the call stack buildup until the base case, followed by the unwinding process that computes the final result.",
      "keyPoints": [
        "Base case: 0! = 1",
        "Recursive case: n! = n × (n-1)!",
        "Stack builds until base case",
        "Unwinding computes final result"
      ],
      "examples": [
        "fact(3): 3 × 2 × 1 = 6",
        "fact(5): 5 × 4 × 3 × 2 × 1 = 120"
      ]
    },
    {
      "id": 9,
      "question": "What is the Tower of Hanoi problem?",
      "answer": "A classic recursive puzzle involving moving disks between pegs with specific constraints.",
      "category": "Recursion Applications",
      "detailedExplanation": "The Tower of Hanoi is a mathematical puzzle that demonstrates recursion perfectly. It consists of three pegs and a number of disks of different sizes that can slide onto any peg.\n\n**Rules:**\n1. Only one disk can be moved at a time\n2. Only the top disk from a peg can be moved\n3. A larger disk can never be placed on top of a smaller disk\n\n**Recursive Solution:**\nTo move n disks from source to destination:\n1. Move n-1 disks from source to auxiliary peg\n2. Move the largest disk from source to destination\n3. Move n-1 disks from auxiliary to destination\n\nThis recursive approach elegantly solves what appears to be a complex problem.",
      "keyPoints": [
        "Three pegs: source, auxiliary, destination",
        "Disks of decreasing size",
        "Recursive solution moves n-1 disks twice",
        "Minimum moves: 2ⁿ - 1"
      ],
      "examples": [
        "3 disks require 7 moves",
        "Algorithm: hanoi(n, src, aux, dest) calls hanoi(n-1, src, dest, aux)"
      ]
    },
    {
      "id": 10,
      "question": "What are the key differences between Recursion and Iteration?",
      "answer": "Recursion uses function calls and stack, while iteration uses loops and counters.",
      "category": "Recursion vs Iteration",
      "detailedExplanation": "**Recursion:**\n- Uses function calls that build a call stack\n- More elegant for certain problems\n- Can be more intuitive for mathematical definitions\n- Higher memory usage due to stack\n- Risk of stack overflow\n\n**Iteration:**\n- Uses loops (for, while, do-while)\n- Generally more efficient\n- Lower memory usage\n- Often faster execution\n- Can be less intuitive for some problems\n\n**When to use which:**\n- Use recursion for tree structures, recursive math, divide-and-conquer\n- Use iteration for simple repetitions, performance-critical code\n- Some problems can be solved with either approach",
      "keyPoints": [
        "Recursion: function calls, stack memory",
        "Iteration: loops, counter variables",
        "Recursion: elegant but potentially inefficient",
        "Iteration: efficient but can be verbose"
      ],
      "examples": [
        "Recursive: Tree traversal, Fibonacci",
        "Iterative: Array processing, simple counting"
      ]
    }
  ],
  "mcqs": [
    {
      "id": 1,
      "question": "What is the most critical component that prevents infinite recursion?",
      "options": [
        "Recursive case",
        "Base case",
        "Function parameters",
        "Return statement"
      ],
      "correctAnswer": "Base case",
      "category": "Recursion Fundamentals"
    },
    {
      "id": 2,
      "question": "Which data structure is used by the system to manage recursive function calls?",
      "options": [
        "Queue",
        "Array",
        "Stack",
        "Linked List"
      ],
      "correctAnswer": "Stack",
      "category": "Recursion Mechanics"
    },
    {
      "id": 3,
      "question": "In tail recursion, where must the recursive call appear?",
      "options": [
        "As the first statement",
        "As the last statement",
        "In the middle of the function",
        "In a separate function"
      ],
      "correctAnswer": "As the last statement",
      "category": "Recursion Types"
    },
    {
      "id": 4,
      "question": "What is the time complexity of a naive recursive Fibonacci function?",
      "options": [
        "O(n)",
        "O(log n)",
        "O(2ⁿ)",
        "O(n²)"
      ],
      "correctAnswer": "O(2ⁿ)",
      "category": "Recursion Analysis"
    },
    {
      "id": 5,
      "question": "Which of these is an example of indirect recursion?",
      "options": [
        "Function A calls itself",
        "Function A calls Function B, which calls Function A",
        "Function A calls Function B, which calls Function C",
        "Function A calls multiple copies of itself"
      ],
      "correctAnswer": "Function A calls Function B, which calls Function A",
      "category": "Recursion Types"
    },
    {
      "id": 6,
      "question": "What error occurs if recursion goes too deep without reaching a base case?",
      "options": [
        "NullPointerException",
        "ArrayIndexOutOfBounds",
        "StackOverflowError",
        "MemoryLeakError"
      ],
      "correctAnswer": "StackOverflowError",
      "category": "Recursion Mechanics"
    }
  ]
}
